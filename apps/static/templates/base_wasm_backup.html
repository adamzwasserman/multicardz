<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}MultiCardz - WASM{% endblock %}</title>

    <!-- Base template styles -->
    {% block head %}{% endblock %}

    <!-- Google Fonts for Dongle -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dongle:wght@300;400;700&display=swap" rel="stylesheet">

    <!-- HTMX for dynamic content loading -->
    <script src="https://unpkg.com/htmx.org@1.9.12/dist/htmx.min.js"></script>

    <!-- WASM-specific CSS -->
    <link rel="stylesheet" href="/static/css/wasm-interface.css">

    {% block extra_head %}{% endblock %}
</head>
<body class="font-inconsolata" data-workspace="{{ workspace_id | default('default-workspace') }}" data-user="{{ user_id | default('anonymous-user') }}">
    {% block body %}
    <!-- Navigation Header -->
    <nav class="main-navigation">
        <div class="nav-container">
            <div class="brand">
                <a href="/" class="brand-link">mult<span class="brand-i">i</span>cardz</a>
            </div>
            <div class="nav-menu">
                <ul class="nav-items">
                    <li class="nav-item"><a href="/features">Features</a></li>
                    <li class="nav-item projects-menu-container">
                        <div class="projects-menu"
                             hx-get="/api/v2/projects/menu"
                             hx-trigger="load"
                             hx-swap="innerHTML">
                            <a href="#" class="projects-link">Projects</a>
                        </div>
                    </li>
                    <li class="nav-item"><a href="/pricing">Pricing</a></li>
                    <li class="nav-item">
                        <a href="/trial" class="cta-button">Start Free Trial</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="wasm-container">
        {% block content %}{% endblock %}
    </div>
    {% endblock %}

    <!-- MultiCardz Drag-Drop JavaScript -->
    {% block dragdrop_scripts %}
    <script src="/static/js/drag-drop.js"></script>
    <script>
        // MultiCardz™ initialization
        console.log('MultiCardz™ drag-drop system loading...');

        // Get workspace and user IDs from HTML data attributes
        const workspace = document.body.dataset.workspace || 'default-workspace';
        const user = document.body.dataset.user || 'anonymous-user';

        console.log('Context:', { workspace, user });

        // Initialize on DOM ready (drag-drop.js handles the rest)
        document.addEventListener('DOMContentLoaded', () => {
            console.log('MultiCardz™ DOM ready, drag-drop system initializing...');
        });

        // JavaScript functions for the new drag-drop system
        let dragDropSystem = null;

        function toggleMode() {
            // Mode toggle is now handled through DOM controls
            const modeControl = document.querySelector('[data-affects-rendering="true"][name*="mode"]');
            if (modeControl) {
                modeControl.checked = !modeControl.checked;
                if (dragDropSystem) {
                    dragDropSystem.handleControlChange();
                }
            }
        }

        function toggleTheme() {
            // Theme toggle handled by CSS classes
            document.body.classList.toggle('dark-theme');
        }

        function debugZones() {
            if (dragDropSystem) {
                const state = dragDropSystem.deriveStateFromDOM();
                console.log('Zone state:', state);
            }
        }

        function clearState() {
            if (dragDropSystem) {
                dragDropSystem.clearSelection();
                // Clear all zones by moving tags back to cloud
                const zones = document.querySelectorAll('.drop-zone');
                zones.forEach(zone => {
                    const tags = zone.querySelectorAll('.tag');
                    tags.forEach(tag => {
                        const cloud = document.querySelector('.tag-cloud .tags-wrapper');
                        if (cloud) cloud.appendChild(tag);
                    });
                });
                dragDropSystem.updateStateAndRender();
                console.log('State cleared');
            }
        }

        function debugSystem() {
            console.log('Drag-Drop System:', dragDropSystem);
            if (dragDropSystem) {
                console.log('Current state:', dragDropSystem.deriveStateFromDOM());
            }
        }

        function reloadSystem() {
            location.reload();
        }

        function inspectState() {
            if (dragDropSystem) {
                const state = dragDropSystem.deriveStateFromDOM();
                const totalTags = Object.values(state.zones || {}).reduce((sum, zone) => sum + zone.tags.length, 0);
                console.log('Total tags in zones:', totalTags);
                console.log('Selected tags:', dragDropSystem.selectedTags.size);
                console.log('Full state:', state);
            }
        }

        function togglePerformanceMonitor() {
            console.log('Performance monitoring toggled');
            // Could implement performance monitoring here
        }

        // Initialize the new drag-drop system
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof SpatialDragDrop !== 'undefined') {
                dragDropSystem = new SpatialDragDrop();
                console.log('MultiCardz™ drag-drop system initialized');
            } else {
                console.error('SpatialDragDrop class not found - ensure drag-drop.js is loaded');
            }
        });

        // Legacy functions removed - all drag-drop functionality is now handled by SpatialDragDrop class
        async function handleTagDrop(event) {
            console.log('handleTagDrop called');
            event.preventDefault();

            const zone = event.currentTarget;
            zone.classList.remove('drag-over');

            try {
                // Get drag data
                console.log('Getting drag data...');
                const dragDataString = event.dataTransfer.getData('application/json');
                console.log('Drag data string:', dragDataString);
                if (!dragDataString) {
                    console.warn('No drag data found');
                    return;
                }

                console.log('Parsing drag data...');
                const dragData = JSON.parse(dragDataString);
                console.log('Parsed drag data:', dragData);
                const zoneType = zone.dataset.zoneType;
                console.log('Zone type:', zoneType);

                console.log(`Dropping tag ${dragData.tag} onto ${zoneType} zone`);
                console.log('About to call moveTagToZone...');

                // Always move the tag visually first
                try {
                    moveTagToZone(zone, dragData.tag);
                    console.log('moveTagToZone completed successfully');
                } catch (error) {
                    console.error('moveTagToZone failed:', error);
                }

                // Then try to update backend
                if (window.WASMBridge && typeof window.WASMBridge.dispatchOperation === 'function') {
                    try {
                        const result = await window.WASMBridge.dispatchOperation('drag_drop', {
                            source: dragData.source,
                            tag: dragData.tag,
                            target: zoneType
                        });
                        console.log('WASM bridge result:', result);
                    } catch (error) {
                        console.warn('WASM bridge failed, using fallback:', error);
                    }
                } else {
                    // Fallback: Notify WASM of the tag drop so it can handle rendering with proper state
                    try {
                        if (typeof callWasm !== 'undefined') {
                            // Let WASM handle the card rendering with current cardsInPlay state
                            callWasm('tag_dropped', null, ['string', 'string'], [dragData.tag, zoneType]);
                            console.log(`Notified WASM of tag drop: ${dragData.tag} to ${zoneType}`);
                        } else {
                            console.warn('WASM not available - tag moved visually but cards will not filter');

                            // Clear card container with message since we can't properly filter without WASM
                            const cardContainer = document.getElementById('cardContainer');
                            if (cardContainer) {
                                cardContainer.innerHTML = '<p>WASM not loaded. Cards cannot be filtered without WASM integration.</p>';
                            }
                        }
                    } catch (error) {
                        console.warn('Failed to notify WASM of tag drop:', error);
                    }
                }

                // Remove dragging visual state from tag
                const draggedTag = document.querySelector(`[data-tag="${dragData.tag}"]`);
                if (draggedTag) {
                    draggedTag.classList.remove('dragging');
                }

            } catch (error) {
                console.error('Failed to process tag drop:', error);
                zone.classList.remove('drag-over');
            }
        }

        // Move tag visually from cloud to zone (DOM movement only - no destroy/create)
        function moveTagToZone(zone, tagName) {
            const container = zone.querySelector('.tag-collection');
            if (!container) {
                console.warn('No tag-collection container found in zone:', zone);
                return;
            }

            // Find the original tag in the tag cloud to move it
            const originalTag = document.querySelector(`.cloud-user .tags-wrapper [data-tag="${tagName}"]`);
            if (!originalTag) {
                console.warn('Original tag not found in cloud:', tagName);
                return;
            }

            // Check if tag is already in this zone
            if (container.querySelector(`[data-tag="${tagName}"]`)) {
                console.log('Tag already exists in zone:', tagName);
                return;
            }

            // IMMUTABLE MOVEMENT: Move the existing DOM element to zone
            // Add zone-specific attributes while preserving original tag
            originalTag.classList.add('tag-active');
            originalTag.onclick = () => removeTagFromZone(tagName, zone.dataset.zoneType);

            // Move the original tag DOM element to the zone (preserves all attributes)
            container.appendChild(originalTag);

            console.log(`Tag "${tagName}" moved to ${zone.dataset.zoneType} zone`);

            // Update tags in play display
            updateTagsInPlayDisplay();
        }

        // Remove tag from zone (DOM movement only - no destroy/create)
        async function removeTagFromZone(tagName, zoneType) {
            try {
                // Find tag in zone
                const zoneContainer = document.querySelector(`[data-zone-type="${zoneType}"] .tag-collection`);
                const tagElement = zoneContainer?.querySelector(`[data-tag="${tagName}"]`);
                if (!tagElement) {
                    console.warn('Tag not found in zone:', tagName, zoneType);
                    return;
                }

                // Determine correct cloud container based on original tag type
                const tagType = tagElement.dataset.type || 'tag';
                const cloudSelector = tagType === 'tag' ? '.cloud-user .tags-wrapper' : '.cloud-ai .tags-wrapper';
                const cloudContainer = document.querySelector(cloudSelector);

                if (!cloudContainer) {
                    console.warn('Cloud container not found for tag type:', tagType);
                    return;
                }

                // IMMUTABLE MOVEMENT: Move the existing DOM element back to cloud
                // Remove zone-specific attributes while preserving original tag
                tagElement.classList.remove('tag-active');
                tagElement.onclick = null; // Remove zone click handler

                // Restore original cloud CSS classes and attributes based on tag type
                if (tagType === 'ai-tag') {
                    // Restore AI tag classes and click handler
                    tagElement.className = 'tag tag-ai';
                    tagElement.onclick = () => callWasm('remove_tag', null, ['string'], [tagName]);
                } else {
                    // Restore user tag classes (no onclick for user tags)
                    tagElement.className = 'tag tag-user';
                }

                // Move the original tag DOM element back to cloud (preserves all attributes)
                cloudContainer.appendChild(tagElement);
                console.log(`Tag "${tagName}" moved back to cloud`);

                // Call API to update filtering
                const response = await fetch('/api/v2/tags/render', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        [zoneType + '_tags']: []
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.cards) {
                        const cardContainer = document.getElementById('cardContainer');
                        if (cardContainer) {
                            cardContainer.innerHTML = result.cards
                                .map(card => `<div class="card">${card.title || card.name}</div>`)
                                .join('');
                        }
                    }
                }

                updateTagsInPlayDisplay();

            } catch (error) {
                console.error('Failed to remove tag from zone:', error);
            }
        }

        // Update the tags in play display
        function updateTagsInPlayDisplay() {
            const tagsInPlayField = document.getElementById('tagsInPlay');
            if (!tagsInPlayField) return;

            const unionTags = Array.from(document.querySelectorAll('#union_tags .tag-collection [data-tag]'))
                .map(el => el.dataset.tag);
            const intersectionTags = Array.from(document.querySelectorAll('#intersection_tags .tag-collection [data-tag]'))
                .map(el => el.dataset.tag);

            const state = {
                union: unionTags,
                intersection: intersectionTags,
                row: [],
                column: []
            };

            tagsInPlayField.value = JSON.stringify(state, null, 2);
        }

        // Checkbox state management functions for RENDERING settings (affect card display)
        function updateCheckboxState(checkboxKey, isChecked) {
            const tagsInPlayField = document.getElementById('tagsInPlay');
            if (!tagsInPlayField) {
                console.warn('tagsInPlay field not found');
                return;
            }

            try {
                // Parse current state
                let currentState = {};
                if (tagsInPlayField.value && tagsInPlayField.value !== '') {
                    currentState = JSON.parse(tagsInPlayField.value);
                }

                // Initialize checkboxes object if it doesn't exist
                if (!currentState.checkboxes) {
                    currentState.checkboxes = {};
                }

                // Update the specific checkbox state
                currentState.checkboxes[checkboxKey] = isChecked;

                // Update the field with pretty printing
                tagsInPlayField.value = JSON.stringify(currentState, null, 2);

                console.log(`Rendering setting updated: ${checkboxKey} = ${isChecked}`);

                // Apply CSS classes for visual state changes
                if (checkboxKey === 'show_colors') {
                    if (isChecked) {
                        document.body.classList.add('show-colors');
                    } else {
                        document.body.classList.remove('show-colors');
                    }
                }

                if (checkboxKey === 'start_with_cards_expanded') {
                    if (isChecked) {
                        document.body.classList.add('cards-expanded');
                    } else {
                        document.body.classList.remove('cards-expanded');
                    }
                }

                // Save to database asynchronously
                saveCheckboxToDatabase(checkboxKey, isChecked);

            } catch (error) {
                console.error('Failed to update rendering setting:', error);
            }
        }

        // UI-only settings (don't affect card rendering, just save to database)
        function updateUISettingState(checkboxKey, isChecked) {
            console.log(`UI setting updated: ${checkboxKey} = ${isChecked}`);

            // Save to database asynchronously (no tagsInPlay update)
            saveCheckboxToDatabase(checkboxKey, isChecked);
        }

        // Save individual checkbox state to database
        async function saveCheckboxToDatabase(checkboxKey, isChecked) {
            try {
                const userId = getUserId(); // Get current user ID

                // Get all current checkbox states
                const checkboxStates = getAllCheckboxStates();
                checkboxStates[checkboxKey] = isChecked;

                const response = await fetch('/api/settings/checkboxes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        checkbox_states: checkboxStates
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log(`Checkbox ${checkboxKey} saved to database:`, result);

            } catch (error) {
                console.error(`Failed to save checkbox ${checkboxKey} to database:`, error);
            }
        }

        // Get current user ID (default to 'default' for now)
        function getUserId() {
            // For now, use a default user ID. In a real app, this would come from authentication
            return 'default';
        }

        // Get current workspace ID (for database selection)
        function getUserWorkspace() {
            // Try to get from global state, fallback to default
            return window.currentWorkspace || 'marketing.db';
        }

        // Get current state of all zones
        function getCurrentZoneState() {
            const state = {
                union: [],
                intersection: [],
                row: [],
                column: []
            };

            // Collect tags from each zone
            const unionZone = document.getElementById('union_tags');
            if (unionZone) {
                const unionTags = unionZone.querySelectorAll('.tag');
                state.union = Array.from(unionTags).map(tag => tag.dataset.tag || tag.textContent.trim());
            }

            const intersectionZone = document.getElementById('intersection_tags');
            if (intersectionZone) {
                const intersectionTags = intersectionZone.querySelectorAll('.tag');
                state.intersection = Array.from(intersectionTags).map(tag => tag.dataset.tag || tag.textContent.trim());
            }

            const rowZone = document.getElementById('rows');
            if (rowZone) {
                const rowTags = rowZone.querySelectorAll('.tag');
                state.row = Array.from(rowTags).map(tag => tag.dataset.tag || tag.textContent.trim());
            }

            const columnZone = document.getElementById('columns');
            if (columnZone) {
                const columnTags = columnZone.querySelectorAll('.tag');
                state.column = Array.from(columnTags).map(tag => tag.dataset.tag || tag.textContent.trim());
            }

            return state;
        }

        // Get all current checkbox states from DOM
        function getAllCheckboxStates() {
            const checkboxes = {
                start_with_all_cards: false,
                start_with_cards_expanded: false,
                show_colors: true,
                optimized_render_mode: true,
                earth_tones: false,
                vertical_layout: false,
                advanced_view: false,
                dark_mode: false
            };

            // Read current states from DOM
            const startWithAllCards = document.getElementById('startWithAllCards');
            if (startWithAllCards) checkboxes.start_with_all_cards = startWithAllCards.checked;

            const startWithCardsExpanded = document.getElementById('startWithCardsExpanded');
            if (startWithCardsExpanded) checkboxes.start_with_cards_expanded = startWithCardsExpanded.checked;

            const showColors = document.getElementById('showColors');
            if (showColors) checkboxes.show_colors = showColors.checked;

            const renderMode = document.getElementById('renderMode');
            if (renderMode) checkboxes.optimized_render_mode = renderMode.checked;

            const earthTones = document.getElementById('earthTones');
            if (earthTones) checkboxes.earth_tones = earthTones.checked;

            const verticalLayout = document.getElementById('verticalLayout');
            if (verticalLayout) checkboxes.vertical_layout = verticalLayout.checked;

            const advancedView = document.getElementById('advancedView');
            if (advancedView) checkboxes.advanced_view = advancedView.checked;

            const darkMode = document.getElementById('darkMode');
            if (darkMode) checkboxes.dark_mode = darkMode.checked;

            return checkboxes;
        }

        async function initializeCheckboxStates() {
            const tagsInPlayField = document.getElementById('tagsInPlay');
            if (!tagsInPlayField) {
                console.warn('tagsInPlay field not found during initialization');
                return;
            }

            try {
                // Load checkbox states from database
                const userId = getUserId();
                const savedCheckboxes = await loadCheckboxStatesFromDatabase(userId);

                // Parse current zone state or initialize
                let currentState = {};
                if (tagsInPlayField.value && tagsInPlayField.value !== '') {
                    currentState = JSON.parse(tagsInPlayField.value);
                } else {
                    // Initialize default zone structure
                    currentState = {
                        union: [],
                        intersection: [],
                        row: [],
                        column: []
                    };
                }

                // Set only RENDERING checkboxes from database (not UI-only settings)
                currentState.checkboxes = {
                    start_with_all_cards: savedCheckboxes.start_with_all_cards || false,
                    start_with_cards_expanded: savedCheckboxes.start_with_cards_expanded || false,
                    show_colors: savedCheckboxes.show_colors !== undefined ? savedCheckboxes.show_colors : true,
                    optimized_render_mode: savedCheckboxes.optimized_render_mode !== undefined ? savedCheckboxes.optimized_render_mode : true
                };

                // Apply checkbox states to DOM elements
                applyCheckboxStatesToDOM(savedCheckboxes);

                // Update the field with pretty printing
                tagsInPlayField.value = JSON.stringify(currentState, null, 2);

                // Initialize advanced view state (AI tags visibility)
                if (typeof callWasm === 'function') {
                    const advancedViewEnabled = savedCheckboxes.advanced_view || false;
                    callWasm('toggle_advanced_view', null, ['number'], [advancedViewEnabled ? 1 : 0]);
                    console.log('Advanced view initialized:', advancedViewEnabled);
                }

                console.log('Checkbox states loaded from database and applied:', savedCheckboxes);

            } catch (error) {
                console.error('Failed to initialize checkbox states from database:', error);

                // Fallback: use current DOM states
                const fallbackStates = getAllCheckboxStates();
                const currentState = {
                    union: [],
                    intersection: [],
                    row: [],
                    column: [],
                    checkboxes: fallbackStates
                };
                tagsInPlayField.value = JSON.stringify(currentState, null, 2);

                // Initialize advanced view state (AI tags visibility) with fallback
                if (typeof callWasm === 'function') {
                    const advancedViewEnabled = fallbackStates.advanced_view || false;
                    callWasm('toggle_advanced_view', null, ['number'], [advancedViewEnabled ? 1 : 0]);
                    console.log('Advanced view initialized (fallback):', advancedViewEnabled);
                }

                console.log('Using fallback checkbox states from DOM:', fallbackStates);
            }
        }

        // Load checkbox states from database
        async function loadCheckboxStatesFromDatabase(userId) {
            try {
                const response = await fetch(`/api/settings/checkboxes/${userId}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Loaded checkbox states from database:', result);
                return result.checkbox_states;

            } catch (error) {
                console.error('Failed to load checkbox states from database:', error);

                // Return default values on error
                return {
                    start_with_all_cards: false,
                    start_with_cards_expanded: false,
                    show_colors: true,
                    optimized_render_mode: true,
                    earth_tones: false,
                    vertical_layout: false,
                    advanced_view: false,
                    dark_mode: false
                };
            }
        }

        // Apply checkbox states to DOM elements
        function applyCheckboxStatesToDOM(checkboxStates) {
            try {
                const startWithAllCards = document.getElementById('startWithAllCards');
                if (startWithAllCards) {
                    startWithAllCards.checked = checkboxStates.start_with_all_cards || false;
                }

                const startWithCardsExpanded = document.getElementById('startWithCardsExpanded');
                if (startWithCardsExpanded) {
                    startWithCardsExpanded.checked = checkboxStates.start_with_cards_expanded || false;
                    // Apply cards-expanded CSS class based on checkbox state
                    if (startWithCardsExpanded.checked) {
                        document.body.classList.add('cards-expanded');
                    } else {
                        document.body.classList.remove('cards-expanded');
                    }
                }

                const showColors = document.getElementById('showColors');
                if (showColors) {
                    showColors.checked = checkboxStates.show_colors !== undefined ? checkboxStates.show_colors : true;
                    // Apply show-colors CSS class based on checkbox state
                    if (showColors.checked) {
                        document.body.classList.add('show-colors');
                    } else {
                        document.body.classList.remove('show-colors');
                    }
                }

                const renderMode = document.getElementById('renderMode');
                if (renderMode) {
                    renderMode.checked = checkboxStates.optimized_render_mode !== undefined ? checkboxStates.optimized_render_mode : true;
                }

                const earthTones = document.getElementById('earthTones');
                if (earthTones) {
                    earthTones.checked = checkboxStates.earth_tones || false;
                }

                const verticalLayout = document.getElementById('verticalLayout');
                if (verticalLayout) {
                    verticalLayout.checked = checkboxStates.vertical_layout || false;
                }

                const advancedView = document.getElementById('advancedView');
                if (advancedView) {
                    advancedView.checked = checkboxStates.advanced_view || false;
                }

                const darkMode = document.getElementById('darkMode');
                if (darkMode) {
                    darkMode.checked = checkboxStates.dark_mode || false;
                }

                console.log('Applied checkbox states to DOM elements');

            } catch (error) {
                console.error('Failed to apply checkbox states to DOM:', error);
            }
        }

        // Pretty print JSON in tagsInPlay field
        function prettyPrintTagsInPlay() {
            const tagsInPlayField = document.getElementById('tagsInPlay');
            if (!tagsInPlayField) return;

            try {
                const currentValue = tagsInPlayField.value;
                if (currentValue && currentValue.trim() !== '') {
                    const parsed = JSON.parse(currentValue);
                    tagsInPlayField.value = JSON.stringify(parsed, null, 2);
                }
            } catch (error) {
                console.warn('Could not pretty print tagsInPlay JSON:', error);
            }
        }

        // Font selection persistence functions
        async function saveFontSelection(fontName) {
            try {
                const userId = getUserId();

                const response = await fetch('/api/settings/font', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        font_name: fontName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log(`Font ${fontName} saved to database:`, result);

            } catch (error) {
                console.error(`Failed to save font ${fontName} to database:`, error);
            }
        }

        async function loadFontSelection() {
            try {
                const userId = getUserId();
                const response = await fetch(`/api/settings/font/${userId}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Loaded font selection from database:', result);
                return result.font_name;

            } catch (error) {
                console.error('Failed to load font selection from database:', error);
                return 'helvetica'; // Default font
            }
        }

        function setFont(fontName, displayName, className) {
            // Update WASM state
            if (typeof callWasm === 'function') {
                callWasm('set_font', null, ['string'], [fontName]);
            }

            // Update UI
            const currentElement = document.querySelector('.font-dropdown-current');
            if (currentElement) {
                currentElement.textContent = displayName;
                currentElement.className = `font-dropdown-current ${className}`;
            }

            // Save to database
            saveFontSelection(fontName);

            console.log(`Font set to: ${fontName}`);
        }

        // Initialize font selection from database
        async function initializeFontSelection() {
            try {
                const savedFont = await loadFontSelection();
                console.log('Initializing font selection:', savedFont);

                // Apply font based on saved value
                const fontMapping = {
                    'berkeley-mono': { display: 'Berkeley Mono', className: 'font-berkeley-mono' },
                    'inconsolata': { display: 'Inconsolata 200', className: 'font-inconsolata' },
                    'optima': { display: 'Lato', className: 'font-optima' },
                    'helvetica': { display: 'Libre Franklin', className: 'font-helvetica' },
                    'merriweather': { display: 'Merriweather Sans Light', className: 'font-merriweather' },
                    'avenir': { display: 'Mulish', className: 'font-avenir' },
                    'sanfrancisco': { display: 'Roboto', className: 'font-sanfrancisco' },
                    'akzidenz': { display: 'Work Sans', className: 'font-akzidenz' }
                };

                const fontInfo = fontMapping[savedFont] || fontMapping['helvetica'];

                // Update WASM state (don't save again - just initialize)
                if (typeof callWasm === 'function') {
                    callWasm('set_font', null, ['string'], [savedFont]);
                }

                // Update UI
                const currentElement = document.querySelector('.font-dropdown-current');
                if (currentElement) {
                    currentElement.textContent = fontInfo.display;
                    currentElement.className = `font-dropdown-current ${fontInfo.className}`;
                }

                console.log('Font selection initialized:', savedFont);

            } catch (error) {
                console.error('Failed to initialize font selection:', error);
            }
        }

        // Database switching functionality removed - using HTMX-only implementation

        // Simple Database Loading Function
        // Store last used database in localStorage
        function storeLastUsedDatabase(workspaceId) {
            try {
                localStorage.setItem('lastUsedDatabase', workspaceId);
                console.log(`Stored last used database: ${workspaceId}`);
            } catch (error) {
                console.warn('Failed to store last used database:', error);
            }
        }

        // Get last used database from localStorage
        function getLastUsedDatabase() {
            try {
                return localStorage.getItem('lastUsedDatabase');
            } catch (error) {
                console.warn('Failed to get last used database:', error);
                return null;
            }
        }

        // Check if this is first-ever load
        function isFirstEverLoad() {
            try {
                return !localStorage.getItem('hasLoadedBefore');
            } catch (error) {
                return true; // Assume first load if localStorage fails
            }
        }

        // Mark that user has loaded a database before
        function markAsLoaded() {
            try {
                localStorage.setItem('hasLoadedBefore', 'true');
            } catch (error) {
                console.warn('Failed to mark as loaded:', error);
            }
        }

        async function loadDatabase(workspaceId) {
            try {
                console.log(`Loading database: ${workspaceId}`);

                // Create form data for the existing /api/switch-database endpoint
                const formData = new FormData();
                formData.append('database_path', workspaceId);

                // Call existing database switching endpoint
                const response = await fetch('/api/switch-database', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const htmlContent = await response.text();

                    // Set current workspace for future API calls
                    window.currentWorkspace = workspaceId;

                    // First, load the database metadata (tags, etc.) from the backend response
                    if (htmlContent.includes('<script>')) {
                        // New format: Execute the returned script to update page elements (tags, etc.)
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = htmlContent;
                        const script = tempDiv.querySelector('script');
                        if (script) {
                            eval(script.textContent);
                        }
                        console.log(`Database metadata loaded: ${workspaceId}`);
                    } else {
                        // Old format: Extract tags from HTML and update them
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = htmlContent;

                        // Extract and update tag cloud
                        const tagCloud = tempDiv.querySelector('.tag-cloud, [id*="tag"]');
                        if (tagCloud) {
                            const existingTagCloud = document.querySelector('.tag-cloud, [id*="tag"]');
                            if (existingTagCloud) {
                                existingTagCloud.innerHTML = tagCloud.innerHTML;
                            }
                        }
                        console.log(`Database metadata loaded (fallback mode): ${workspaceId}`);
                    }

                    // Now render cards with checkbox state awareness
                    console.log('WASM not available, using direct frontend rendering with checkbox state');
                    const tagsInPlay = getActiveFilters();
                    const startWithAllCards = document.getElementById('startWithAllCards')?.checked || false;
                    const hasActiveFilters = tagsInPlay.union.length > 0 || tagsInPlay.intersection.length > 0;

                    // Use same logic as updateCardVisibilityFromCheckbox
                    const cardContainer = document.getElementById('cardContainer');
                    const emptyStateMessage = document.querySelector('.empty-state-message') || document.querySelector('#emptyStateMessage');

                    if (startWithAllCards || hasActiveFilters) {
                        // Hide empty state message
                        if (emptyStateMessage) {
                            emptyStateMessage.style.display = 'none';
                        }

                        await renderCardsWithCheckboxes(tagsInPlay, startWithAllCards);
                        console.log(`Database loaded and cards rendered with checkbox state: ${workspaceId}`);
                    } else {
                        // Clear card container and show empty state
                        if (cardContainer) {
                            const existingCards = cardContainer.querySelectorAll('.card');
                            existingCards.forEach(card => card.remove());
                        }

                        if (emptyStateMessage) {
                            emptyStateMessage.textContent = 'No cards to display';
                            emptyStateMessage.style.display = 'block';
                        }

                        console.log(`Database loaded but no cards displayed: startWithAllCards=${startWithAllCards}, hasActiveFilters=${hasActiveFilters}`);
                    }

                    // Store as last used database and mark as loaded
                    storeLastUsedDatabase(workspaceId);
                    markAsLoaded();
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Failed to load database:', error);
                alert(`Failed to load database: ${error.message}`);
            }
        }

        // Auto-load database on page initialization
        async function autoLoadDatabase() {
            try {
                if (isFirstEverLoad()) {
                    // First-ever load: load tutorial database
                    console.log('First-ever load detected, loading tutorial database');
                    await loadDatabase('tutorial_customer.db');
                } else {
                    // Load last used database
                    const lastUsed = getLastUsedDatabase();
                    if (lastUsed) {
                        console.log(`Loading last used database: ${lastUsed}`);
                        await loadDatabase(lastUsed);
                    } else {
                        // Fallback to tutorial if no last used database
                        console.log('No last used database found, loading tutorial');
                        await loadDatabase('tutorial_customer.db');
                    }
                }
            } catch (error) {
                console.error('Failed to auto-load database:', error);
                // Try tutorial as final fallback
                try {
                    console.log('Attempting tutorial fallback');
                    await loadDatabase('tutorial_customer.db');
                } catch (fallbackError) {
                    console.error('Tutorial fallback also failed:', fallbackError);
                }
            }
        }

    </script>
    {% endblock %}
</body>
</html>
